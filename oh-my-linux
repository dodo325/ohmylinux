#!/usr/bin/env bash
# vim: noai:ts=4:sw=4:expandtab
# shellcheck source=/dev/null
# 
# Oh My Linux  
# https://github.com/dylanaraps/neofetch
#
# The MIT License (MIT)
#
# Copyright (c) 2019-2021 Dodo325
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# This cil script was generated by bashly (https://github.com/DannyBen/bashly)
# 

# Imports:
SCRIPTPATH="$( cd "$(dirname "$0")" >/dev/null 2>&1 ; pwd -P )"
. $SCRIPTPATH/lib/logs.sh --source-only
. $SCRIPTPATH/lib/sysinfo.sh --source-only
. $SCRIPTPATH/lib/tools.sh


requirements=(
  whiptail
)

# Build variables:
BUILD_DIRECTORY=$SCRIPTPATH/build/
BUILD_SCRIPT=$BUILD_DIRECTORY/install.sh
SCRIPTS_DIRECTORY=$SCRIPTPATH/scripts

header_sources=(
    $SCRIPTPATH/lib/logs.sh
    $SCRIPTPATH/lib/sysinfo.sh
    $SCRIPTPATH/lib/header.sh
)
footer_sources=()


# Variables:
scripts_directory_array=();
declare -A scripts_files=();
declare -A scripts_names=();
declare -A scripts_description=();
declare -A scripts_text_assets=();

declare -A depends_on=();
declare -A visited=();
# declare -A stack=();
stack=();
selected_scripts=();

_checklist=;

# ==== Functions =====
check_requirements() {
  # TODO: improve check tools
  for _cmd in "${requirements[@]}"; do 
    if [ "$(command -v $_cmd)" ]; then
      log_success "command \"$_cmd\" exists on system"
    else
      log_warning "command \"$_cmd\" does not exist on system"
      run_script $_cmd
    fi
  done
}

BFS() {
    # Breadth-First Search algorithm
    # this function adds in 'stack' all dependencies for correct script
    
    # USE:
    #   $ BFS vlc

    # OUTPUT:
    # - stack

    local v=$1;
    log_info "Start BFS for '$v'"
    visited[$v]=true;
    local graph=(${depends_on[$v]})
    for i in "${graph[@]}"; do
        if [ "${visited[$i]}" = false ]; then
            BFS "$i"
        fi
    done
    log_info "Adds '$v' in 'stack'"
    stack+=("$v")
}

topological_sort() {
    # his function adds in 'stack' all dependencies for selected_scripts

    # USE:
    #   $ topological_sort

    # OUTPUT:
    # - stack

    log_info "Start topological_sort"

    # initial array
    visited=()
    stack=()

    for v in "${scripts_directory_array[@]}"; do
        visited[$v]=false;
    done

    for v in "${selected_scripts[@]}"; do
        BFS "$v";
    done
}

run_script() {
  # USE:
  #   run_script [SCRIPT_NAME]

  local name=$1

  detect_scripts_directories;

  local script_file=$SCRIPTS_DIRECTORY/$name/${scripts_files[$name]}

  log_info "Run $script_file"
  source $script_file
}

parse_config_file(){
    # Parse .cfg file
    # 
    # Example file:
    # [metadata]
    # name=GUI Checker
    # description=...
    # file=desktop_check.sh

    local _info_file_path=$1

    log_debug "Srart parse $_info_file_path"
    while read line; do
        if [[ $line =~ ^"["(.+)"]"$ ]]; then
            arrname=${BASH_REMATCH[1]}
            declare -A $arrname
        elif [[ $line =~ ^([_[:alpha:]][_[:alnum:]]*)"="(.*) ]]; then
            declare ${arrname}[${BASH_REMATCH[1]}]="${BASH_REMATCH[2]}"
    fi
    done < $_info_file_path

    # Append daat to array:
    scripts_files[$2]=${metadata[file]};
    scripts_description[$2]=${metadata[description]};
    scripts_names[$2]=${metadata[name]};
    depends_on[$2]=${metadata[depends_on]};
    scripts_text_assets[$2]=${assets[text_assets]};

    log_debug "name = ${metadata[name]}";
    log_debug "description = ${metadata[description]}";
    log_debug "file = ${metadata[file]}";
    log_debug "depends_on [$2] = ${metadata[depends_on]}";
    log_debug "scripts_text_assets [$2] = ${assets[text_assets]}";
}

detect_scripts_directories() {
    log_info "Start detecting scripts directories"
    scripts_directory_array=();
    scripts_files=();
    scripts_names=();
    scripts_description=();
    _checklist=;

    for f in $SCRIPTS_DIRECTORY/*; do
        if [ -d "$f" ]; then
            # $f is a directory
            info_file_path=$f/info.cfg;
            if [ ! -f "$info_file_path" ]; then
                continue
            fi
            local dir_name=$(basename $f)
            scripts_directory_array+=($dir_name); # FIXME: ляя
            # scripts_directory_array=("${scripts_directory_array[@]}" "$dir_name")
            # scripts_directory_array[$dir_name]=$dir_name;

            parse_config_file $info_file_path $dir_name
            # а тут мы их используем

            # _checklist+='"${scripts_names[$dir_name]}" "${scripts_names[$description]}" off '
            _checklist+="$dir_name $dir_name off "
        fi
    done
    log_success "Detected: ${scripts_directory_array[@]}"
}

append_script_assets_to_build() {
    log_info "scripts_text_assets = ${scripts_text_assets[$1]}"
    if [ -n "${scripts_text_assets[$1]}" ]; then
        log_debug "add asseets:"
        local text_assets=(${scripts_text_assets[$1]})
        for asset in "${text_assets[@]}"; do
            log_debug "Add $asset";
            append_text_file_to_bash_script $SCRIPTS_DIRECTORY/$name/$asset $BUILD_SCRIPT;
        done
    fi
}

append_script_file_to_build() {
    log_info "Add script to build: $1"
    content=$(cat $1)
    # TODO: repere the script content

    echo "$content" >> $BUILD_SCRIPT    
}

parse_checklist_output() {
    log_info "Start parse: $@"
    for el in "$@"
    do
        echo "- el: $el"
        tmp="${el%\"}"
        tmp="${tmp#\"}"
        echo "-- tmp: $tmp";
        # selected_scripts[$tmp]=$tmp;
        # selected_scripts=("${selected_scripts[@]}" $tmp)
        selected_scripts+=($tmp); #TODOL что-то тут не так
    done
}

remove_script_dir() {
  local _name=$1;
  local _path=$SCRIPTS_DIRECTORY/$_name
  log_warning "Remove $_path"
  rm -rf $_path/
}

append_new_script_dir() {
  local _name=$1;
  local _deps=$2;
  local _path=$SCRIPTS_DIRECTORY/$_name
  
  log_info "_path = $_path"
  if [ -d "$_path" ]; then
      log_success "$_path already exists!"
      return
  fi

  mkdir -p $_path/

  echo "# $_name" > $_path/install.sh
  echo "log_info 'Install $_name'" >> $_path/install.sh 
  echo "" >> $_path/install.sh 

  echo "[metadata]" > $_path/info.cfg
  echo "name=$_name" >> $_path/info.cfg
  echo "description=..." >> $_path/info.cfg
  echo "file=install.sh" >> $_path/info.cfg

  if [ $_deps ]; then
    echo "depends_on=$_deps" >> $_path/info.cfg    
  fi
}

initial_build_directory() {
    if [ -d "$BUILD_DIRECTORY" ]; then
        log_warning "Remove build directory: $BUILD_DIRECTORY"
        rm -rf $BUILD_DIRECTORY;
    fi

    mkdir -p "$BUILD_DIRECTORY"

    touch "$BUILD_SCRIPT";
}

build_script() {
    initial_build_directory;

    # Обновляем зависимости

    # _scripts= $@

    # Для каждого файла мы обрезаем контент 
    for sfile in "${header_sources[@]}"; do
        append_script_file_to_build $sfile;
    done

    for name in "${stack[@]}"; do # 
        log_info "Add script = $name"
        local script_file=$SCRIPTS_DIRECTORY/$name/${scripts_files[$name]}
        log_info "script_file = $script_file"
        append_script_assets_to_build $name;
        append_script_file_to_build "$script_file";
    done

    for sfile in "${footer_sources[@]}"; do
        append_script_file_to_build $sfile;
    done

    # Исправляем файл
    mv $BUILD_SCRIPT $BUILD_SCRIPT.old
    sed "/# skip/d" $BUILD_SCRIPT.old > $BUILD_SCRIPT; # TODO: Remove
    rm $BUILD_SCRIPT.old
}

ask_start_script() {
    
    local dio_name="Statr script?"
    local dio_discription="Statr script?"

    if [ "${args[--run]}" = 1 ]; then
        log_info "Start script!"
        source $BUILD_SCRIPT;

    elif (whiptail --title "$dio_name" --yesno "$dio_discription" 8 78); then
        log_info "Start script!"
        source $BUILD_SCRIPT;
    else
        log_info ""
        echo "USE:"
        echo ""
        echo " $ bash $BUILD_SCRIPT"
        echo ""
    fi
}

select_scripts() {
    if [[ ${args[select]} ]]; then
      selected_scripts=(${args[select]})
    else
      OUTPUT=$(whiptail --checklist "Please pick one" 10 60 4 $_checklist  3>&2 2>&1 1>&3 )
      parse_checklist_output $OUTPUT;
    fi

  log_info "selected_scripts = ${selected_scripts[@]}"
}

# ====== CLI =======
# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
oh_my_linux_usage() {
  if [[ -n $long_usage ]]; then
    printf "oh-my-linux - Oh My Linux\n"
    echo 
  else
    printf "oh-my-linux - Oh My Linux\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  oh-my-linux [command]\n"
  printf "  oh-my-linux [command] --help | -h\n"
  printf "  oh-my-linux --version | -v\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  build   Build script"
  echo "  run     Run the script"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "Environment Variables:\n"
    
    # :environment_variable.usage
    echo "  DEBUG"
    printf "    Enable debug mode\n"
    echo

  fi
}


# :command.usage
oh_my_linux_run_usage() {
  if [[ -n $long_usage ]]; then
    printf "oh-my-linux run - Run the script\n"
    echo 
  else
    printf "oh-my-linux run - Run the script\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  oh-my-linux run SCRIPT [options]\n"
  printf "  oh-my-linux run --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --debug, -d"
    printf "    Enable debug mode\n"
    echo
    
    # :flag.usage
    echo "  --no-logo"
    printf "    Not print logo\n"
    echo
    
    # :flag.usage
    echo "  --sysinfo"
    printf "    Print System info\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  SCRIPT"
    printf "    Script name\n"
    echo

  fi
}

# :command.usage
oh_my_linux_build_usage() {
  if [[ -n $long_usage ]]; then
    printf "oh-my-linux build - Build script\n"
    echo 
  else
    printf "oh-my-linux build - Build script\n"
    echo 
  fi

  printf "Shortcut: b\n"
  echo

  printf "Usage:\n"
  printf "  oh-my-linux build [SELECT] [options]\n"
  printf "  oh-my-linux build --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --debug, -d"
    printf "    Enable debug mode\n"
    echo
    
    # :flag.usage
    echo "  --no-logo"
    printf "    Not print logo\n"
    echo
    
    # :flag.usage
    echo "  --run, -r"
    printf "    Run scripn after building\n"
    echo
    
    # :flag.usage
    echo "  --sysinfo"
    printf "    Print System info\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  SELECT"
    printf "    Selecte some scripts\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  cli build\n"
    printf "  cli build -d -r\n"
    printf "  cli build \"vlc GUI\"\n"
    printf "  cli build --sysinfo \"vlc GUI\"\n"
    echo

  fi
}

# :command.base_parse_flags
base_parse_flags() {
  case "${args[--debug]}" in
        1) DEBUG=true ;;
        *) DEBUG=$DEBUG ;;
  esac

  if [ "${args[--no-logo]}" != 1 ]; then
    print_logo
  fi
  log_debug "DEBUG Mode!"

  update_all_info;

  if [ "${args[--sysinfo]}" = 1 ]; then
    print_all_info
  fi

  if [ "$DEBUG" = true ]; then
    inspect_args
  fi

  check_requirements; # TODO: add flag for this
}

# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if (( ${#args[@]} )); then
    log_debug args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if (( ${#other_args[@]} )); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.command_functions
# :command.function
oh_my_linux_build_command() {
  base_parse_flags;

  detect_scripts_directories;

  select_scripts


  topological_sort; 
  build_script;

  ask_start_script;
}

# :command.command_functions
# :command.function
oh_my_linux_run_command() {
  base_parse_flags;
  
  run_script "${args[script]}";
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    oh_my_linux_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action=$1
  
  case $action in
  -* )
    ;;

  run )
    action="run"
    shift
    oh_my_linux_run_parse_requirements "$@"
    shift $#
    ;;

  build | b )
    action="build"
    shift
    oh_my_linux_build_parse_requirements "$@"
    shift $#
    ;;    
  
  # :command.command_fallback
  * )
    oh_my_linux_usage
    exit 1
    ;;
  
  esac
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
oh_my_linux_run_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    oh_my_linux_run_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="run"
  # :command.required_args_filter
  if [[ $1 && $1 != -* ]]; then
    args[script]=$1
    shift
  else
    printf "missing required argument: SCRIPT\nusage: oh-my-linux run SCRIPT [options]\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --debug | -d )
      args[--debug]=1
      shift
      ;;
  
    # :flag.case
    --no-logo )
      args[--no-logo]=1
      shift
      ;;
  
    # :flag.case
    --sysinfo )
      args[--sysinfo]=1
      shift
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[script]} ]]; then
        args[script]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
oh_my_linux_build_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    oh_my_linux_build_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="build"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --debug | -d )
      args[--debug]=1
      shift
      ;;
  
    # :flag.case
    --no-logo )
      args[--no-logo]=1
      shift
      ;;
  
    # :flag.case
    --run | -r )
      args[--run]=1
      shift
      ;;
  
    # :flag.case
    --sysinfo )
      args[--sysinfo]=1
      shift
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[select]} ]]; then
        args[select]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''

  # if [ "$DEBUG" != true ]; then # TODO: fix it!
  #   set -e  
  # fi

}

# :command.run
run() {
  declare -A args
  declare -a other_args
  parse_requirements "$@"

  if [[ $action == "run" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      oh_my_linux_run_usage
    else
      oh_my_linux_run_command
    fi

  elif [[ $action == "build" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      oh_my_linux_build_usage
    else
      oh_my_linux_build_command
    fi
  
  elif [[ $action == "root" ]]; then
    root_command
  fi
}


if [ "${1}" != "--source-only" ]; then
    initialize
    run "$@"
fi
